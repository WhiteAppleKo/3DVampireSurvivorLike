# 2026-01-07 일일 작업 일지

## 📅 작업 개요
금일은 게임의 시간 제어(TimeScale) 로직 이해, 코루틴 및 오브젝트 생성 방식에 대한 기초 개념 정립, 그리고 몬스터 스폰 로직 구현 및 관련 버그 수정을 진행하였습니다. 특히 싱글톤 초기화 순서로 인한 `NullReferenceException` 문제를 해결하여 안정성을 확보했습니다.

## 📝 상세 작업 내용

### 1. 시간 제어 및 정지 기능
*   **Time.timeScale 활용**: 게임 일시 정지(Pause) 구현을 위해 `Time.timeScale`을 0과 1로 토글하는 로직을 작성했습니다.
*   **TimeScaleManager 분석**: 오브젝트에 부착되지 않아도 작동하는 이유가 `SingletoneBase`의 Lazy Initialization(자동 생성) 패턴 덕분임을 확인하고 구조를 파악했습니다.

### 2. 코루틴 및 인스턴스화 로직 정립
*   **코루틴 흐름 이해**: `while(true)` 루프 진입 전 작성된 코드는 코루틴 시작 시 1회만 실행됨을 명확히 했습니다.
*   **Instantiate 자식 생성**: `Instantiate(prefab, transform)`을 통해 생성과 동시에 부모-자식 관계를 설정하는 효율적인 방법을 정리했습니다.

### 3. 몬스터 스폰 시스템 개선 (`RepeatSpawner`)
*   **조건부 스폰 로직**: `MonsterDatabase`의 `minTime`과 `IMTimer`의 경과 시간을 비교하여, 스폰 가능한 몬스터 리스트(`m_EnemysDatas`)를 갱신하는 `SetEnemys` 함수를 제안했습니다.

### 4. 버그 수정 (`NullReferenceException`)
*   **문제 상황**: `EnemyController`가 `Awake`에서 `IMTimer.Instance`를 참조할 때, `IMTimer`가 아직 초기화되지 않아 참조 오류 발생.
*   **해결책**:
    1.  `IMTimer.cs`: `Awake` 메서드를 추가하여 싱글톤 인스턴스를 명시적으로 초기화하도록 수정.
    2.  `EnemyController.cs`: 초기화 로직을 `Awake`에서 `Start`로 변경하여, 모든 싱글톤이 준비된 후 접근하도록 실행 순서 조정.

## 💡 배운 점 및 특이 사항
*   **싱글톤과 생명주기**: `Awake` 단계에서는 다른 스크립트의 싱글톤 인스턴스가 아직 생성되지 않았을 수 있으므로, 타 싱글톤 참조는 가급적 `Start`에서 수행하거나 `Script Execution Order`를 고려해야 함을 재확인했습니다.
*   **방어적 프로그래밍**: `SingletoneBase`의 자동 생성 기능은 편리하지만, 인스펙터 설정이 필요한 경우에는 주의가 필요함을 확인했습니다.

오늘 작업하신 내용을 나중에 블로그나 GitHub, 노션 등에 바로 활용하실 수 있도록 **Markdown(MD)** 형식의 개발 일지로 정리해 드립니다.

아래 내용을 복사해서 사용하세요!

---

# 📅 개발 일지: 뱀파이어 서바이벌류 몬스터 소환 및 성장 시스템

## 📋 작업 요약

* ID 기반의 몬스터 소환 시스템 구축 (RepeatSpawn)
* ScriptableObject를 활용한 몬스터 데이터베이스 및 스탯 관리
* 시간 경과에 따른 몬스터 스탯 스케일링 로직 구현
* 데이터 관리 효율화를 위한 자동화 방안 검토

---

## 🛠️ 구현 내용

### 1. ID 기반 소환 시스템 및 데이터베이스

* **MonsterDatabase**: `ScriptableObject`를 사용하여 ID(int)와 프리팹(GameObject)을 매칭.
* **자동 연동 아이디어**: 프리팹 이름을 `Monster_ID` 규칙으로 정하고, 에디터 스크립트를 통해 데이터 시트와 프리팹을 자동으로 매칭하는 구조 설계.

### 2. 시간 기반 몬스터 강화 시스템

* **GameTimer**: 싱글톤으로 구현하여 게임 시작 후 흐른 시간을 추적.
* **스탯 공식**: 몬스터 소환 시점에 현재 시간을 체크하여 베이스 스탯에 배율을 곱함.
*


* **데이터 타입 처리**: `int`와 `float` 연산 시 발생하는 소수점을 `Mathf.FloorToInt`를 사용하여 정수로 깔끔하게 처리.

---

## 💻 핵심 코드 조각

### 몬스터 스탯 계산 및 형변환

```csharp
// Mathf.FloorToInt를 사용하여 소수점 이하 버림 처리
public void CalculateFinalStats() {
    float multiplier = GameTimer.Instance.GetHealthMultiplier();
    currentMaxHealth = Mathf.FloorToInt(baseStat.baseMaxHealth * multiplier);
    currentDamage = Mathf.FloorToInt(baseStat.baseDamage * GameTimer.Instance.GetDamageMultiplier());
}

```

---

## 🧠 학습 및 해결 포인트

* **유연한 확장성**: ID 기반 시스템을 통해 `PatternSpawn` 등 다른 소환 로직에서도 `RepeatSpawner`에 ID만 넘겨주면 쉽게 몬스터를 변경할 수 있도록 구조화함.
* **형변환 주의점**: C#에서 `int`와 `float` 곱셈 시 결과가 `float`이 되므로, 정수형 스탯이 필요할 때는 명시적으로 내림(`FloorToInt`) 처리가 필요함을 확인.

---

## 🚀 다음 단계 (To-Do)

* [ ] 특정 시간/조건에 맞춰 몬스터 ID를 변경하는 `PatternSpawn` 구현
* [ ] 대량의 몬스터 처리를 위한 **오브젝트 풀링(Object Pooling)** 적용
* [ ] 몬스터 사망 시 경험치 드랍 및 플레이어 레벨업 시스템 연결

---

**작성된 일지에 추가하고 싶은 세부 내용이나, 바로 이어서 진행할 구현 단계가 있다면 말씀해 주세요!**