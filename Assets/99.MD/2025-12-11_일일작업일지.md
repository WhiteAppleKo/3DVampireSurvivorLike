# 2025년 12월 11일 목요일 - 일일 작업일지

---

## 1. 학습 파트: C# 제네릭 및 추상 클래스를 활용한 `ClampValue` 심층 분석

오늘은 직접 구현하신 `ClampValue<T>` 추상 클래스를 분석하며 제네릭 클래스의 올바른 설계와 사용법에 대해 깊이 학습했습니다.

### 주요 학습 내용

#### 가. `abstract` 클래스와 제네릭의 한계
- **핵심 이유**: `ClampValue<T>`의 `Add`, `Subtract`, `Clamp`가 `abstract`여야 하는 이유는, C# 컴파일러가 제네릭 타입 `T`에 대해 산술 연산(`+`, `-`)을 보장할 수 없으며, `Mathf.Clamp`와 같은 특정 타입 전용 메서드를 사용할 수 없기 때문이다.
- **설계 패턴**: `abstract` 클래스는 '무엇을' 해야 하는지만 정의하는 **설계도** 역할을 하며, 실제 '어떻게' 구현할지는 `override`를 통해 자식 클래스에게 위임하고 강제한다.

#### 나. 구체적인 구현 클래스의 필요성
- `ClampValue<T>`를 사용하기 위해서는 `float` 타입을 위한 `FloatValue`, `int` 타입을 위한 `IntValue`와 같이, 각 타입에 맞는 연산 로직을 실제로 구현한 자식 클래스가 반드시 필요함을 이해했다.

#### 다. 생성자 실행 순서 및 프로퍼티 구현
- 자식 클래스 생성자에서 `: base()`가 먼저 실행되어 부모 클래스의 멤버(`Min`, `Max`, `Current`)가 초기화되고, 그 후에 자식 클래스 생성자의 본문이 실행되는 순서를 파악했다.
- `Ratio`와 같이 `{ get; }`만 있는 추상 프로퍼티는 생성자에서 값을 할당하는 것이 아니라, `override`하여 `get` 접근자 내에 계산 로직을 구현해야 함을 학습했다.

#### 라. `Callback` 이벤트를 이용한 로직 분리
- `Action` 델리게이트를 활용한 `Callback` 시스템의 사용법을 익혔다.
- `+=` 연산자로 이벤트를 구독하여 '값이 변경되면 UI를 업데이트'하는 등, 핵심 로직과 UI 로직을 분리하여 코드의 결합도를 낮출 수 있음을 확인했다.
- 메모리 누수 방지를 위해 `OnDestroy()`에서 `-=`로 이벤트 구독을 해제하는 것의 중요성을 인지했다.

---

## 2. 작업 파트: 자동 공격 시스템 리팩토링 및 개선

기존 자동 공격 관련 스크립트(`AutoAttack`, `Weapon`, `ProjectileWeapon`)를 분석하고 여러 문제점을 수정했다.

### 주요 작업 내용

#### 가. `Attack` 메서드 미작동 문제 해결
- **문제점**: `ProjectileWeapon`이 `Weapon`의 `Attack` 메서드를 `override`하지 않아 투사체 발사가 이루어지지 않던 치명적인 오류를 발견했다.
- **조치**: `Attack` 메서드를 `abstract`로 변경하여 자식 클래스가 반드시 공격 로직을 구현하도록 강제하고, `ProjectileWeapon`에서 이를 `override`하여 타겟 탐색 및 발사 로직을 호출하도록 수정했다.

#### 나. `FindTarget` 타겟 탐색 로직 개선
- **문제점**: 기존 코드가 루프 안에서 `Physics.OverlapSphere`를 반복 호출하여 비효율적이었고, 탐지된 적이 100명을 초과할 경우 `IndexOutOfRangeException` 발생 가능성이 있었다.
- **조치**:
    1.  물리 엔진 호출을 1회로 줄이고, `LayerMask`를 추가하여 특정 레이어의 적만 감지하도록 최적화했다.
    2.  감지된 적들 중 가장 가까운 대상을 찾도록 로직을 개선했다.
    3.  루프를 순회할 때 `Mathf.Min`을 사용하여 배열 인덱스 초과 예외를 방지했다.
