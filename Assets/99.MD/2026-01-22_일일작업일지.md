# 2026-01-22 일일 작업 일지

## 작업 요약
- **ChargeDashWeapon.cs** 스크립트 구현 및 분석
- UniTask를 활용한 비동기 돌진 및 공격 로직 구현
- 타겟 탐지 및 오버슈트(Overshoot) 이동 로직 구현

## 상세 작업 내용 : ChargeDashWeapon.cs 분석

오늘 작업한 `ChargeDashWeapon` 스크립트는 적을 향해 충전(Charge) 후 돌진(Dash)하며 경로상의 적들을 공격하는 무기 시스템입니다. 주요 로직을 단계별로 분석합니다.

### 1. 초기화 및 변수 설정 (`WeaponSettingLogic`)
```csharp
public override void WeaponSettingLogic()
{
    // 자기 자신을 참조하기 때문에 테스트 해볼 필요 있음
    m_Controller = GetComponentInParent<Controller>();
    m_TargetColliders = new Collider[20];
}
```
- `WeaponSettingLogic`: 무기가 초기화될 때 호출됩니다.
- `GetComponentInParent<Controller>()`: 플레이어 컨트롤러를 가져와 돌진 상태(`isCharging`) 제어 및 위치 이동에 사용합니다.
- `m_TargetColliders`: `Physics.OverlapSphereNonAlloc`에서 사용할 콜라이더 배열을 미리 할당하여 가비지 생성을 줄입니다 (최대 20개).

### 2. 공격 시작 로직 (`AttackLogic`)
```csharp
public override void AttackLogic()
{
    // 이미 공격 준비 중이면 로직을 건너 뜀
    if (m_IsDashing)
    {
        return;
    }
    base.AttackLogic();

    m_CurrentTarget = FindTarget();
    if (m_CurrentTarget != null)
    {
        SetTarget(m_CurrentTarget);
        Charge(m_CurrentTarget).Forget();
    }
    else SetTarget(null);
}
```
- **중복 실행 방지**: `m_IsDashing` 플래그를 체크하여 이미 돌진 중일 때 중복 공격을 방지합니다.
- **타겟 탐지**: `FindTarget()`으로 가장 가까운 적을 찾습니다.
- **비동기 실행**: 타겟이 있다면 `Charge` 루틴을 비동기(`UniTask`)로 실행합니다. `.Forget()`을 사용하여 결과를 기다리지 않고 실행만 시킵니다.

### 3. 돌진 및 공격 메인 루틴 (`Charge`)
이 함수는 `UniTaskVoid`를 사용하여 비동기로 동작하며, **충전(대기) -> 돌진**의 순서를 가집니다.

#### 3-1. 초기 설정 및 목표 지점 계산
```csharp
// Safe Token : 오브젝트가 파괴되면 작업 취소
CancellationToken token = this.GetCancellationTokenOnDestroy();
m_IsDashing = true;
m_Controller.isCharging = m_IsDashing;
m_HitEnemies.Clear();

// 타겟 방향 벡터 및 도착 지점 계산
Vector3 startPos = m_Controller.transform.position;
Vector3 targetPos = currenttTarget.transform.position;
Vector3 direction = (targetPos - startPos).normalized;
float distanceToTarget = Vector3.Distance(startPos, targetPos);

// 타겟을 지나쳐서(overShootDistance) 더 이동할 최종 위치
Vector3 endPos = startPos + direction * (distanceToTarget + overShootDistance);
```
- **CancellationToken**: 돌진 중 오브젝트가 파괴되거나 비활성화될 경우 작업을 안전하게 취소하기 위해 토큰을 생성합니다.
- **상태 설정**: `m_IsDashing`과 컨트롤러의 `isCharging`을 true로 설정하여 플레이어의 다른 조작을 제한합니다.
- **도착 지점 계산**: 타겟 위치를 지나쳐 `overShootDistance`만큼 더 이동하도록 `endPos`를 계산합니다. 이는 적을 뚫고 지나가는 느낌을 줍니다.

#### 3-2. 충전(Charge) 단계 (공격 딜레이)
```csharp
float chargeDuration = FinalStats.attackDelay;
float currentChargeTime = 0f;

while (currentChargeTime < chargeDuration)
{
    if (token.IsCancellationRequested) return;
    
    currentChargeTime += Time.deltaTime;
    float progress = Mathf.Clamp01(currentChargeTime / chargeDuration) / 2;
    
    // 시각적 연출 업데이트 (삼각형 모양 변경 등)
    UpdateChargeVisuals(progress);
    
    await UniTask.NextFrame(PlayerLoopTiming.Update, token);
}
```
- **충전 대기**: `FinalStats.attackDelay` 만큼 대기합니다. 단순 `Delay` 대신 `while` 루프를 사용하여 매 프레임 `UpdateChargeVisuals`를 호출, 충전 연출(Shapes 등)을 제어합니다.

#### 3-3. 돌진(Dash) 단계
```csharp
float elapsedTime = 0f;
while (elapsedTime < dashDuration)
{
    if (token.IsCancellationRequested) return;

    elapsedTime += Time.deltaTime;
    float t = elapsedTime / dashDuration;
    
    // 위치 이동 (Lerp)
    m_Controller.transform.position = Vector3.Lerp(startPos, endPos, t);

    // 돌진 중 충돌 체크 및 데미지 적용
    ChargeAttack(currenttTarget);

    await UniTask.NextFrame(PlayerLoopTiming.Update, token);
}
// 루프 종료 후 최종 위치 보정
m_Controller.transform.position = endPos;
ChargeAttack(currenttTarget);
```
- **위치 이동**: `Vector3.Lerp`를 사용하여 `startPos`에서 `endPos`로 부드럽게 이동합니다.
- **충돌 판정**: 매 프레임 `ChargeAttack`을 호출하여 경로상의 적을 감지합니다.

#### 3-4. 종료 및 정리 (`finally`)
```csharp
finally
{
    m_IsDashing = false;
    m_Controller.isCharging = m_IsDashing;
}
```
- `finally` 블록을 사용하여 작업이 정상 종료되거나 취소(Cancel)되더라도 반드시 상태 플래그(`m_IsDashing`)를 해제하도록 보장합니다.

### 4. 충돌 감지 및 데미지 적용 (`ChargeAttack`)
```csharp
private void ChargeAttack(GameObject target)
{
    // 현재 플레이어 위치 기준 반경(hitRadius) 내 적 감지
    int hitCount = Physics.OverlapSphereNonAlloc(target.transform.position, hitRadius, m_TargetColliders, targetLayer);

    for (int i = 0; i < hitCount; i++)
    {
        GameObject enemyObj = m_TargetColliders[i].gameObject;
        int enemyId = enemyObj.GetInstanceID();
        
        // 중복 타격 방지: 이번 돌진에서 맞지 않은 적만 타격
        if (!m_HitEnemies.Contains(enemyId))
        {
            m_HitEnemies.Add(enemyId);
            ApplyDamage(enemyObj);
        }
    }
}
```
- **OverlapSphereNonAlloc**: 가비지 컬렉션을 최소화하며 주변 적을 감지합니다. 여기서 `target.transform.position`을 사용하고 있는데, **플레이어 자신의 위치(`m_Controller.transform.position`)를 기준으로 해야 하는지 확인이 필요해 보입니다.** (현재 코드는 `target` 인자를 받고 있는데, 돌진 중에는 플레이어 몸체가 휩쓸고 지나가는 것이므로 플레이어 위치 기준이 맞을 수 있음. *코드 상에서는 `target.transform.position`을 넘기는데, 호출부 `Charge` 함수에서는 `currenttTarget`(적)을 넘기고 있어 돌진 중 적 위치 주변만 판정하는지 의도 확인 필요*) -> **수정 제안**: 돌진은 플레이어가 몸으로 부딪히는 것이므로 `m_Controller.transform.position`을 기준으로 판정하는 것이 더 자연스러울 수 있음.
- **HashSet 사용**: `m_HitEnemies` 해시셋을 사용하여 한 번의 돌진 동작 중에 동일한 적이 여러 번 데미지를 입지 않도록 관리합니다.

### 5. 타겟 탐색 (`FindTarget`)
```csharp
private GameObject FindTarget()
{
    // 증강 스탯 범위 내 적 탐색
    int size = Physics.OverlapSphereNonAlloc(transform.position, FinalStats.chargeWeaponStat.findTargetRange, m_TargetColliders, targetLayer);
    
    // 가장 가까운 적 탐색 로직 (거리 제곱 비교)
    // ...
}
```
- 가장 가까운 적을 찾아 타겟으로 설정합니다. 거리 계산 시 `sqrMagnitude`를 사용하여 제곱근 연산을 피해 성능을 최적화했습니다.

## 특이사항 및 점검 포인트
1. **충돌 판정 기준**: `ChargeAttack` 내부에서 `Physics.OverlapSphereNonAlloc`의 기준 위치가 인자로 받은 `target`의 위치인지, 아니면 돌진 중인 `Player`의 위치여야 하는지 점검이 필요합니다. 현재 로직상 `target`(적) 주변만 때리는지, 플레이어가 이동하면서 경로상을 때리는지 확인.
2. **비동기 안전성**: `UniTask`와 `CancellationToken`을 사용하여 오브젝트 파괴 시 발생할 수 있는 오류를 적절히 방어하고 있습니다.
