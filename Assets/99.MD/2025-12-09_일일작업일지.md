# 2025년 12월 09일 작업일지

## 1. 금일 작업 내용 요약
Unity Input System을 사용하여 플레이어 이동 및 회전, 마우스 컨트롤 기능을 구현했습니다. (2025년 12월 09일)

---

## 2. 작업 내용 요약
-   Unity의 새로운 Input System 설정 및 `PlayerController` 스크립트와의 연동 문제 해결.
-   키보드 입력(WASD)을 받아 캐릭터를 XZ 평면에서 이동시키는 기능 구현.
-   캐릭터가 이동하는 방향을 바라보도록 부드러운 회전 기능 추가.
-   마우스 오른쪽 버튼을 누르고 있는 동안 마우스 커서를 따라 캐릭터가 이동하는 기능 구현.
-   키보드와 마우스 입력이 충돌하지 않도록 입력 우선순위 로직 적용 (키보드 우선).

---

## 3. 자세한 설명 (코드 분석)

### Input System 설정 (`.inputactions.meta`)
-   초기 `PlayerController`가 `InputSystem_Actions`를 인식하지 못하는 문제는 `.inputactions` 에셋의 C# 클래스가 생성되지 않았기 때문이었습니다.
-   `.meta` 파일의 `generateWrapperCode` 값을 `1`로 변경하여 `InputSystem_Actions.cs` 클래스가 자동 생성되도록 하여 문제를 해결했습니다.

### `PlayerController.cs` 핵심 로직

#### 입력 처리 방식 변경
-   **초기**: `RightClick.performed` 이벤트를 구독하고 `Hold` 상호작용을 통해 마우스 클릭 지점을 한 번만 받아오도록 구현.
-   **최종**: "마우스를 누르는 동안 계속 따라오는" 요구사항을 충족하기 위해, `Update()` 내에서 `RightClick.IsPressed()`를 사용하여 매 프레임 버튼의 '눌림 상태'를 직접 확인하는 방식으로 변경. 이는 반복적인 동작에 더 적합합니다.

#### `UpdateMovement()` 메서드 분석
```csharp
private void UpdateMovement()
{
    // 1. 키보드 입력을 먼저 확인
    m_InputVector = m_InputActions.Player.Move.ReadValue<Vector2>();

    // 2. 키보드 입력 우선 처리
    if (m_InputVector.sqrMagnitude > 0.01f)
    {
        m_Movement = new Vector3(m_InputVector.x, 0f, m_InputVector.y);
    }
    // 3. 키보드 입력이 없을 때만 마우스 상태 확인
    else if (m_InputActions.UI.RightClick.IsPressed())
    {
        Ray ray = Camera.main.ScreenPointToRay(Mouse.current.position.ReadValue());
        if (Physics.Raycast(ray, out RaycastHit hit, 1000f, groundLayerMask))
        {
            Vector3 targetPosition = hit.point;
        
            // 커서가 캐릭터와 너무 가까우면 멈춤 (진동 방지)
            if (Vector3.Distance(transform.position, targetPosition) < stopDistance)
            {
                 m_Movement = Vector3.zero;
            }
            else
            {
                // 이동 방향 설정
                m_Movement = (targetPosition - transform.position).normalized;
            }
        }
    }
    else
    {
        // 아무 입력이 없으면 정지
        m_Movement = Vector3.zero;
    }

    // 이동 및 회전 적용
    if (m_Movement.sqrMagnitude > 0.01f)
    {
        // Space.World: 월드 좌표계 기준 이동
        transform.Translate(m_Movement.normalized * moveSpeed * Time.deltaTime, Space.World);
    
        // Quaternion.LookRotation: 바라볼 방향 벡터로 회전값 생성
        Quaternion targetRotation = Quaternion.LookRotation(m_Movement);
        // Quaternion.Slerp: 부드러운 회전 적용
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, turnSpeed * Time.deltaTime);
    }
}
```

---

## 4. 금일 학습 내용 (Q&A 요약)

-   **`performed`의 의미는?**
    -   Input System에서 입력이 '수행'되었을 때 발생하는 **이벤트**.
    -   `Tap`, `Hold` 등 설정된 상호작용(Interaction) 조건을 만족했을 때 단발적으로 호출됩니다.

-   **`Hold`를 쓰고 싶은데, 왜 `IsPressed()`로 바꿨나?**
    -   `Hold`는 지정된 시간을 누르면 이벤트를 **한 번**만 발생시킵니다.
    -   "누르는 동안 계속 반복"되는 로직을 원했기 때문에, `Update()`에서 매 프레임 `IsPressed()`로 버튼의 '상태'를 직접 확인하는 것이 올바른 구현 방식입니다.

-   **`m_Movement != Vector3.zero` 대신 `m_Movement.sqrMagnitude > 0.01f`를 쓰는 이유는?**
    -   컴퓨터의 **부동 소수점 정밀도 한계** 때문입니다.
    -   계산 과정에서 벡터 값이 완벽한 `(0,0,0)`이 아닌 `(0.00001, 0, -0.00002)`처럼 미세한 값을 가질 수 있어 `!= Vector3.zero` 비교는 불안정합니다.
    -   따라서 벡터 길이의 제곱(`sqrMagnitude`)이 0에 아주 가까운 작은 값(`0.01f` 등)보다 큰지를 확인하는 것이 더 안정적이고 효율적인 방법입니다.
